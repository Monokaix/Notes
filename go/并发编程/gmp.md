# GMP

1. 最多创建10000个M，也就是内核级线程，但最多有`GOMAXPROCS` 个活跃线程能够正常运行

2. 数据结构

   ```go
   type m struct {
   	g0   *g
   	curg *g
   	...
   }
   ```

   其中 g0 是持有调度栈的 Goroutine，也就是自举协程。`curg` 是在当前线程上运行的用户 Goroutine，这也是操作系统线程唯一关心的两个 Goroutine。

   g0 是一个运行时中比较特殊的 Goroutine，它会深度参与运行时的调度过程，包括 Goroutine 的创建、大内存分配和 CGO 函数的执行

3. p在空闲时会唤醒一个m。

4. 当执行非阻塞调用时，m和g与p解绑，此时m会记着p，当系统调用结束继续找之前那个p，若p空闲则接着执行，若p有任务在执行，则获取其他p，若仍没有空闲p，则将g放入全局队列。

5. 系统中有个`sysmon`线程(不与任何p绑定，相当于一个独立的内核线程)进行一下系统监控

    - 检查死锁
    - 运行计时器(`goready`唤醒一个到期的计时器执行)
    - 网络轮询
    - 抢占处理器
    - 垃圾回收